import { z } from 'zod';
import { createTRPCRouter, protectedProcedure } from '../trpc';
import { analyzeAppraisalPenetration } from '@/lib/agents/appraisal-penetration';
import { TRPCError } from '@trpc/server';

/**
 * Appraisal Penetration Router
 * Integrates with the appraisal-penetration agent
 */
export const appraisalRouter = createTRPCRouter({
  /**
   * Analyze appraisal penetration for a dealership
   */
  analyze: protectedProcedure
    .input(
      z.object({
        dealershipId: z.string().uuid(),
        dealershipUrl: z.string().url(),
        dealershipName: z.string(),
        location: z.string(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      try {
        console.log(`ğŸš€ Starting appraisal penetration analysis for ${input.dealershipName}`);

        // Run the appraisal penetration agent
        const result = await analyzeAppraisalPenetration(
          input.dealershipUrl,
          input.dealershipName,
          input.location
        );

        // Store results in database
        const { data: analysis, error } = await ctx.db
          .from('appraisal_analysis')
          .insert({
            tenant_id: ctx.tenant.id,
            dealership_id: input.dealershipId,
            penetration_score: result.penetrationScore,
            form_quality_score: result.formQualityScore,
            ai_visibility_score: result.aiVisibilityScore,
            forms_discovered: result.formsDiscovered,
            ai_platform_results: result.aiPlatformResults,
            competitive_analysis: result.competitiveAnalysis,
            recommendations: result.recommendations,
            detailed_analysis: result.detailedAnalysis,
            created_at: new Date().toISOString(),
          })
          .select()
          .single();

        if (error) {
          console.error('Failed to store appraisal analysis:', error);
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to store analysis results',
          });
        }

        // Log API usage
        await ctx.db.from('api_usage').insert({
          tenant_id: ctx.tenant.id,
          user_id: ctx.user.id,
          service_name: 'appraisal_analysis',
          cost: 0.03, // Estimated cost
          metadata: { dealershipId: input.dealershipId },
          created_at: new Date().toISOString(),
        });

        console.log(`âœ… Appraisal penetration analysis complete`);

        return {
          success: true,
          analysis: {
            id: analysis.id,
            ...result,
          },
        };
      } catch (error) {
        console.error('Appraisal analysis failed:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Analysis failed',
        });
      }
    }),

  /**
   * Get latest appraisal analysis for a dealership
   */
  getLatest: protectedProcedure
    .input(z.object({ dealershipId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data: analysis, error } = await ctx.db
        .from('appraisal_analysis')
        .select('*')
        .eq('dealership_id', input.dealershipId)
        .eq('tenant_id', ctx.tenant.id)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (error && error.code !== 'PGRST116') {
        // PGRST116 = no rows
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch analysis',
        });
      }

      return analysis || null;
    }),

  /**
   * List all appraisal analyses for a dealership
   */
  list: protectedProcedure
    .input(
      z.object({
        dealershipId: z.string().uuid(),
        limit: z.number().min(1).max(100).default(10),
        offset: z.number().min(0).default(0),
      })
    )
    .query(async ({ ctx, input }) => {
      const { data: analyses, error, count } = await ctx.db
        .from('appraisal_analysis')
        .select('*', { count: 'exact' })
        .eq('dealership_id', input.dealershipId)
        .eq('tenant_id', ctx.tenant.id)
        .order('created_at', { ascending: false })
        .range(input.offset, input.offset + input.limit - 1);

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch analyses',
        });
      }

      return {
        analyses: analyses || [],
        total: count || 0,
        hasMore: (count || 0) > input.offset + input.limit,
      };
    }),

  /**
   * Get appraisal analysis by ID
   */
  getById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data: analysis, error } = await ctx.db
        .from('appraisal_analysis')
        .select('*')
        .eq('id', input.id)
        .eq('tenant_id', ctx.tenant.id)
        .single();

      if (error || !analysis) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Analysis not found',
        });
      }

      return analysis;
    }),

  /**
   * Get appraisal penetration trends over time
   */
  getTrends: protectedProcedure
    .input(
      z.object({
        dealershipId: z.string().uuid(),
        months: z.number().min(1).max(12).default(6),
      })
    )
    .query(async ({ ctx, input }) => {
      const startDate = new Date();
      startDate.setMonth(startDate.getMonth() - input.months);

      const { data: analyses, error } = await ctx.db
        .from('appraisal_analysis')
        .select('penetration_score, form_quality_score, ai_visibility_score, created_at')
        .eq('dealership_id', input.dealershipId)
        .eq('tenant_id', ctx.tenant.id)
        .gte('created_at', startDate.toISOString())
        .order('created_at', { ascending: true });

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch trends',
        });
      }

      // Format for AI Visibility Card TrendPoint[] format
      return {
        penetrationTrend: (analyses || []).map((a, i) => ({
          t: i,
          v: a.penetration_score,
        })),
        formQualityTrend: (analyses || []).map((a, i) => ({
          t: i,
          v: a.form_quality_score,
        })),
        aiVisibilityTrend: (analyses || []).map((a, i) => ({
          t: i,
          v: a.ai_visibility_score,
        })),
        timestamps: (analyses || []).map((a) => a.created_at),
      };
    }),
});
