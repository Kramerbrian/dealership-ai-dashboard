{
  "version": "1.0.0",
  "export_date": "2025-11-07",
  "framework": "Customer Lifecycle & PLG Metrics",
  "files": [
    {
      "path": "lib/lifecycle/framework.ts",
      "contents": "/**\n * Customer Lifecycle Framework\n * \n * Tracks user progression through: Idle → Recognized → Personalized → Activated → Integrated → Retained\n */\n\nexport type LifecycleStage = \n  | 'idle'\n  | 'recognized'\n  | 'personalized'\n  | 'activated'\n  | 'integrated'\n  | 'retained';\n\nexport interface LifecycleState {\n  stage: LifecycleStage;\n  userId: string;\n  tenantId: string;\n  enteredAt: Date;\n  metadata?: Record<string, any>;\n}\n\nexport interface LifecycleMetrics {\n  // Domain-to-First Fix: < 60s (proves \"magnetic\" pull)\n  domainToFirstFixSeconds: number | null;\n  domainToFirstFixTimestamp: Date | null;\n  \n  // Integrations / Dealer (Day 7): ≥ 2 (PLG adoption)\n  integrationsAtDay7: number;\n  integrationsList: string[];\n  \n  // Retention (D7): > 60% (curiosity sustained)\n  retentionDay7: boolean;\n  retentionDay7Timestamp: Date | null;\n  \n  // Avg Unlocked Pulses: ≥ 6 / 12 (engagement)\n  unlockedPulsesCount: number;\n  unlockedPulsesTotal: number;\n  unlockedPulsesRatio: number;\n  \n  // Time to First Value: < 2 min (immediate dopamine)\n  timeToFirstValueSeconds: number | null;\n  timeToFirstValueTimestamp: Date | null;\n}\n\nexport const LIFECYCLE_STAGES: LifecycleStage[] = [\n  'idle',\n  'recognized',\n  'personalized',\n  'activated',\n  'integrated',\n  'retained'\n];\n\nexport function getNextStage(current: LifecycleStage): LifecycleStage | null {\n  const index = LIFECYCLE_STAGES.indexOf(current);\n  return index < LIFECYCLE_STAGES.length - 1 ? LIFECYCLE_STAGES[index + 1] : null;\n}\n\nexport function getStageProgress(stage: LifecycleStage): number {\n  const index = LIFECYCLE_STAGES.indexOf(stage);\n  return ((index + 1) / LIFECYCLE_STAGES.length) * 100;\n}\n\nexport function isStageComplete(stage: LifecycleStage, metrics: LifecycleMetrics): boolean {\n  switch (stage) {\n    case 'idle':\n      return true; // Always starts here\n    case 'recognized':\n      return metrics.timeToFirstValueSeconds !== null && metrics.timeToFirstValueSeconds < 120;\n    case 'personalized':\n      return metrics.unlockedPulsesRatio >= 0.5; // ≥ 6/12\n    case 'activated':\n      return metrics.domainToFirstFixSeconds !== null && metrics.domainToFirstFixSeconds < 60;\n    case 'integrated':\n      return metrics.integrationsAtDay7 >= 2;\n    case 'retained':\n      return metrics.retentionDay7 === true;\n    default:\n      return false;\n  }\n}\n"
    },
    {
      "path": "lib/lifecycle/metrics.ts",
      "contents": "/**\n * Lifecycle Metrics Tracking\n * \n * Tracks key PLG metrics:\n * - Domain-to-First Fix: < 60s\n * - Integrations / Dealer (Day 7): ≥ 2\n * - Retention (D7): > 60%\n * - Avg Unlocked Pulses: ≥ 6 / 12\n * - Time to First Value: < 2 min\n */\n\nimport { LifecycleMetrics } from './framework';\nimport { storeTelemetry } from '@/lib/telemetry/storage';\n\nconst METRIC_TARGETS = {\n  domainToFirstFix: 60, // seconds\n  integrationsDay7: 2,\n  retentionDay7: 0.6, // 60%\n  unlockedPulsesRatio: 0.5, // 6/12 = 0.5\n  timeToFirstValue: 120 // seconds (2 minutes)\n} as const;\n\nexport interface MetricEvent {\n  type: 'domain_to_first_fix' | 'integration_added' | 'pulse_unlocked' | 'first_value' | 'day7_check';\n  userId: string;\n  tenantId: string;\n  timestamp: Date;\n  value?: number;\n  metadata?: Record<string, any>;\n}\n\nexport class LifecycleMetricsTracker {\n  private metrics: Map<string, LifecycleMetrics> = new Map();\n\n  async trackDomainToFirstFix(userId: string, tenantId: string, seconds: number): Promise<void> {\n    const key = `${userId}:${tenantId}`;\n    const current = this.getMetrics(userId, tenantId);\n    \n    current.domainToFirstFixSeconds = seconds;\n    current.domainToFirstFixTimestamp = new Date();\n    \n    this.metrics.set(key, current);\n    \n    await storeTelemetry({\n      event_type: 'lifecycle_metric',\n      tenant_id: tenantId,\n      user_id: userId,\n      metadata: {\n        metric: 'domain_to_first_fix',\n        value: seconds,\n        target: METRIC_TARGETS.domainToFirstFix,\n        met_target: seconds < METRIC_TARGETS.domainToFirstFix\n      },\n      timestamp: new Date()\n    });\n  }\n\n  async trackIntegration(userId: string, tenantId: string, integrationName: string): Promise<void> {\n    const current = this.getMetrics(userId, tenantId);\n    \n    if (!current.integrationsList.includes(integrationName)) {\n      current.integrationsList.push(integrationName);\n      current.integrationsAtDay7 = current.integrationsList.length;\n    }\n    \n    await storeTelemetry({\n      event_type: 'lifecycle_metric',\n      tenant_id: tenantId,\n      user_id: userId,\n      metadata: {\n        metric: 'integration_added',\n        integration: integrationName,\n        total_integrations: current.integrationsAtDay7,\n        target: METRIC_TARGETS.integrationsDay7,\n        met_target: current.integrationsAtDay7 >= METRIC_TARGETS.integrationsDay7\n      },\n      timestamp: new Date()\n    });\n  }\n\n  async trackPulseUnlock(userId: string, tenantId: string): Promise<void> {\n    const current = this.getMetrics(userId, tenantId);\n    \n    current.unlockedPulsesCount++;\n    current.unlockedPulsesTotal = 12; // Total available pulses\n    current.unlockedPulsesRatio = current.unlockedPulsesCount / current.unlockedPulsesTotal;\n    \n    await storeTelemetry({\n      event_type: 'lifecycle_metric',\n      tenant_id: tenantId,\n      user_id: userId,\n      metadata: {\n        metric: 'pulse_unlocked',\n        count: current.unlockedPulsesCount,\n        ratio: current.unlockedPulsesRatio,\n        target: METRIC_TARGETS.unlockedPulsesRatio,\n        met_target: current.unlockedPulsesRatio >= METRIC_TARGETS.unlockedPulsesRatio\n      },\n      timestamp: new Date()\n    });\n  }\n\n  async trackTimeToFirstValue(userId: string, tenantId: string, seconds: number): Promise<void> {\n    const current = this.getMetrics(userId, tenantId);\n    \n    if (!current.timeToFirstValueSeconds) {\n      current.timeToFirstValueSeconds = seconds;\n      current.timeToFirstValueTimestamp = new Date();\n      \n      await storeTelemetry({\n        event_type: 'lifecycle_metric',\n        tenant_id: tenantId,\n        user_id: userId,\n        metadata: {\n          metric: 'time_to_first_value',\n          value: seconds,\n          target: METRIC_TARGETS.timeToFirstValue,\n          met_target: seconds < METRIC_TARGETS.timeToFirstValue\n        },\n        timestamp: new Date()\n      });\n    }\n  }\n\n  async checkDay7Retention(userId: string, tenantId: string, signupDate: Date): Promise<boolean> {\n    const daysSinceSignup = (Date.now() - signupDate.getTime()) / (1000 * 60 * 60 * 24);\n    \n    if (daysSinceSignup >= 7) {\n      const current = this.getMetrics(userId, tenantId);\n      // Check if user has been active in last 7 days\n      const isRetained = current.timeToFirstValueSeconds !== null && \n                         current.unlockedPulsesCount > 0;\n      \n      current.retentionDay7 = isRetained;\n      current.retentionDay7Timestamp = new Date();\n      \n      await storeTelemetry({\n        event_type: 'lifecycle_metric',\n        tenant_id: tenantId,\n        user_id: userId,\n        metadata: {\n          metric: 'day7_retention',\n          retained: isRetained,\n          target: METRIC_TARGETS.retentionDay7,\n          met_target: isRetained\n        },\n        timestamp: new Date()\n      });\n      \n      return isRetained;\n    }\n    \n    return false;\n  }\n\n  getMetrics(userId: string, tenantId: string): LifecycleMetrics {\n    const key = `${userId}:${tenantId}`;\n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, {\n        domainToFirstFixSeconds: null,\n        domainToFirstFixTimestamp: null,\n        integrationsAtDay7: 0,\n        integrationsList: [],\n        retentionDay7: false,\n        retentionDay7Timestamp: null,\n        unlockedPulsesCount: 0,\n        unlockedPulsesTotal: 12,\n        unlockedPulsesRatio: 0,\n        timeToFirstValueSeconds: null,\n        timeToFirstValueTimestamp: null\n      });\n    }\n    return this.metrics.get(key)!;\n  }\n\n  getMetricsSummary(userId: string, tenantId: string) {\n    const metrics = this.getMetrics(userId, tenantId);\n    \n    return {\n      domainToFirstFix: {\n        value: metrics.domainToFirstFixSeconds,\n        target: METRIC_TARGETS.domainToFirstFix,\n        met: metrics.domainToFirstFixSeconds !== null && metrics.domainToFirstFixSeconds < METRIC_TARGETS.domainToFirstFix\n      },\n      integrationsDay7: {\n        value: metrics.integrationsAtDay7,\n        target: METRIC_TARGETS.integrationsDay7,\n        met: metrics.integrationsAtDay7 >= METRIC_TARGETS.integrationsDay7\n      },\n      retentionDay7: {\n        value: metrics.retentionDay7,\n        target: METRIC_TARGETS.retentionDay7,\n        met: metrics.retentionDay7\n      },\n      unlockedPulses: {\n        value: metrics.unlockedPulsesCount,\n        ratio: metrics.unlockedPulsesRatio,\n        target: METRIC_TARGETS.unlockedPulsesRatio,\n        met: metrics.unlockedPulsesRatio >= METRIC_TARGETS.unlockedPulsesRatio\n      },\n      timeToFirstValue: {\n        value: metrics.timeToFirstValueSeconds,\n        target: METRIC_TARGETS.timeToFirstValue,\n        met: metrics.timeToFirstValueSeconds !== null && metrics.timeToFirstValueSeconds < METRIC_TARGETS.timeToFirstValue\n      }\n    };\n  }\n}\n\nexport const lifecycleMetrics = new LifecycleMetricsTracker();\n"
    },
    {
      "path": "app/api/lifecycle/metrics/route.ts",
      "contents": "import { NextRequest, NextResponse } from 'next/server';\nimport { lifecycleMetrics } from '@/lib/lifecycle/metrics';\nimport { enforceTenantIsolation } from '@/lib/api-protection/tenant-isolation';\n\nexport const dynamic = 'force-dynamic';\n\nexport async function GET(req: NextRequest) {\n  try {\n    const isolation = await enforceTenantIsolation(req);\n    if (!isolation.allowed || !isolation.tenantId) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    const { searchParams } = new URL(req.url);\n    const userId = searchParams.get('userId') || isolation.tenantId;\n    \n    const summary = lifecycleMetrics.getMetricsSummary(userId, isolation.tenantId);\n    \n    return NextResponse.json({\n      success: true,\n      metrics: summary,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error: any) {\n    console.error('Lifecycle metrics error:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch metrics' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const isolation = await enforceTenantIsolation(req);\n    if (!isolation.allowed || !isolation.tenantId) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    const body = await req.json();\n    const { event, value, metadata } = body;\n    const userId = body.userId || isolation.tenantId;\n    \n    switch (event) {\n      case 'domain_to_first_fix':\n        await lifecycleMetrics.trackDomainToFirstFix(userId, isolation.tenantId, value);\n        break;\n      case 'integration_added':\n        await lifecycleMetrics.trackIntegration(userId, isolation.tenantId, metadata?.integration || 'unknown');\n        break;\n      case 'pulse_unlocked':\n        await lifecycleMetrics.trackPulseUnlock(userId, isolation.tenantId);\n        break;\n      case 'time_to_first_value':\n        await lifecycleMetrics.trackTimeToFirstValue(userId, isolation.tenantId, value);\n        break;\n      case 'day7_check':\n        const signupDate = metadata?.signupDate ? new Date(metadata.signupDate) : new Date();\n        await lifecycleMetrics.checkDay7Retention(userId, isolation.tenantId, signupDate);\n        break;\n      default:\n        return NextResponse.json(\n          { error: 'Unknown event type' },\n          { status: 400 }\n        );\n    }\n    \n    return NextResponse.json({ success: true });\n  } catch (error: any) {\n    console.error('Lifecycle tracking error:', error);\n    return NextResponse.json(\n      { error: 'Failed to track event' },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "path": "components/lifecycle/LifecycleDashboard.tsx",
      "contents": "\"use client\";\n\nimport React, { useEffect, useState } from 'react';\nimport { motion } from 'framer-motion';\nimport { CheckCircle2, Clock, Target, TrendingUp } from 'lucide-react';\nimport { lifecycleMetrics } from '@/lib/lifecycle/metrics';\nimport { LIFECYCLE_STAGES, getStageProgress, type LifecycleStage } from '@/lib/lifecycle/framework';\n\ninterface MetricsSummary {\n  domainToFirstFix: { value: number | null; target: number; met: boolean };\n  integrationsDay7: { value: number; target: number; met: boolean };\n  retentionDay7: { value: boolean; target: number; met: boolean };\n  unlockedPulses: { value: number; ratio: number; target: number; met: boolean };\n  timeToFirstValue: { value: number | null; target: number; met: boolean };\n}\n\nexport default function LifecycleDashboard({ userId, tenantId }: { userId: string; tenantId: string }) {\n  const [metrics, setMetrics] = useState<MetricsSummary | null>(null);\n  const [currentStage, setCurrentStage] = useState<LifecycleStage>('idle');\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    async function fetchMetrics() {\n      try {\n        const res = await fetch(`/api/lifecycle/metrics?userId=${userId}`);\n        const data = await res.json();\n        if (data.success) {\n          setMetrics(data.metrics);\n          // Determine current stage based on metrics\n          determineStage(data.metrics);\n        }\n      } catch (error) {\n        console.error('Failed to fetch metrics:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchMetrics();\n  }, [userId]);\n\n  function determineStage(metrics: MetricsSummary) {\n    if (metrics.retentionDay7.met) {\n      setCurrentStage('retained');\n    } else if (metrics.integrationsDay7.met) {\n      setCurrentStage('integrated');\n    } else if (metrics.domainToFirstFix.met) {\n      setCurrentStage('activated');\n    } else if (metrics.unlockedPulses.met) {\n      setCurrentStage('personalized');\n    } else if (metrics.timeToFirstValue.met) {\n      setCurrentStage('recognized');\n    } else {\n      setCurrentStage('idle');\n    }\n  }\n\n  if (loading) {\n    return <div className=\"p-6\">Loading lifecycle metrics...</div>;\n  }\n\n  if (!metrics) {\n    return <div className=\"p-6\">No metrics available</div>;\n  }\n\n  const progress = getStageProgress(currentStage);\n\n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"border rounded-lg p-6 bg-white/80 backdrop-blur\">\n        <h2 className=\"text-2xl font-semibold mb-4\">Customer Lifecycle</h2>\n        \n        {/* Stage Progress Bar */}\n        <div className=\"mb-6\">\n          <div className=\"flex justify-between text-sm text-gray-600 mb-2\">\n            <span>Current Stage: <strong className=\"text-gray-900\">{currentStage}</strong></span>\n            <span>{Math.round(progress)}% Complete</span>\n          </div>\n          <div className=\"w-full bg-gray-200 rounded-full h-3 overflow-hidden\">\n            <motion.div\n              className=\"bg-blue-600 h-full\"\n              initial={{ width: 0 }}\n              animate={{ width: `${progress}%` }}\n              transition={{ duration: 0.5 }}\n            />\n          </div>\n          <div className=\"flex justify-between mt-2 text-xs text-gray-500\">\n            {LIFECYCLE_STAGES.map((stage) => (\n              <span key={stage} className={currentStage === stage ? 'font-semibold text-blue-600' : ''}>\n                {stage}\n              </span>\n            ))}\n          </div>\n        </div>\n\n        {/* Metrics Grid */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n          <MetricCard\n            title=\"Domain-to-First Fix\"\n            value={metrics.domainToFirstFix.value ? `${metrics.domainToFirstFix.value}s` : 'Not started'}\n            target={`< ${metrics.domainToFirstFix.target}s`}\n            met={metrics.domainToFirstFix.met}\n            why=\"Proves \"magnetic\" pull\"\n          />\n          <MetricCard\n            title=\"Integrations (Day 7)\"\n            value={`${metrics.integrationsDay7.value} / ${metrics.integrationsDay7.target}`}\n            target=\"≥ 2\"\n            met={metrics.integrationsDay7.met}\n            why=\"PLG adoption\"\n          />\n          <MetricCard\n            title=\"Retention (D7)\"\n            value={metrics.retentionDay7.value ? 'Retained' : 'Not retained'}\n            target=\"> 60%\"\n            met={metrics.retentionDay7.met}\n            why=\"Curiosity sustained\"\n          />\n          <MetricCard\n            title=\"Unlocked Pulses\"\n            value={`${metrics.unlockedPulses.value} / 12`}\n            target=\"≥ 6 / 12\"\n            met={metrics.unlockedPulses.met}\n            why=\"Engagement\"\n          />\n          <MetricCard\n            title=\"Time to First Value\"\n            value={metrics.timeToFirstValue.value ? `${metrics.timeToFirstValue.value}s` : 'Not started'}\n            target={`< ${metrics.timeToFirstValue.target}s`}\n            met={metrics.timeToFirstValue.met}\n            why=\"Immediate dopamine\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction MetricCard({ title, value, target, met, why }: {\n  title: string;\n  value: string;\n  target: string;\n  met: boolean;\n  why: string;\n}) {\n  return (\n    <motion.div\n      className={`p-4 rounded-lg border ${\n        met ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'\n      }`}\n      whileHover={{ scale: 1.02 }}\n      transition={{ duration: 0.2 }}\n    >\n      <div className=\"flex items-start justify-between mb-2\">\n        <h3 className=\"font-semibold text-sm\">{title}</h3>\n        {met ? (\n          <CheckCircle2 className=\"w-5 h-5 text-green-600\" />\n        ) : (\n          <Clock className=\"w-5 h-5 text-gray-400\" />\n        )}\n      </div>\n      <div className=\"text-2xl font-bold mb-1\">{value}</div>\n      <div className=\"text-xs text-gray-600\">Target: {target}</div>\n      <div className=\"text-xs text-gray-500 mt-1\">{why}</div>\n    </motion.div>\n  );\n}\n"
    }
  ]
}

